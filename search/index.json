[{"content":"Securing Azure Identities: The ‚ÄúNew‚Äù Perimeter in Cloud Security\nIt‚Äôs no secret that the cloud has fundamentally changed how we approach cybersecurity. The days when a robust firewall was all you needed to keep attackers at bay are long gone. As cloud-native services increasingly move into the public sphere, identity has emerged as the new defensive perimeter‚Äîif an attacker compromises your identities and credentials, they‚Äôre essentially inside.\nWhy Identities Matter More Than Ever If you‚Äôve participated in a cybersecurity roundtable recently, you‚Äôve likely heard someone mention, ‚ÄúIdentity is the new perimeter.‚Äù Historically, once you were inside a corporate network, you had broad access to internal systems‚Äîmuch like walking through a front door and freely wandering the house. However, the widespread adoption of cloud services‚Äîaccessible from anywhere‚Äîhas turned this model upside down.\nNavigating Azure Identities Given that identities are the linchpin of security, it‚Äôs crucial to understand the different identity types available in Azure. This variety can be a blessing or a curse. On one hand, multiple identity types allow for flexibility across diverse use cases; on the other, choosing the wrong type can inadvertently weaken your security posture.\nBelow is a quick overview of the most common identities in Azure; for the sake of brevity, we‚Äôll focus primarily on user and service principal identities:\nUser Identities Member Users\nCreated and managed within Microsoft Entra ID (formerly Azure AD), or synced from on-premises Active Directory via Entra ID Connect. Guest Users\nExternal accounts invited through Azure AD B2B collaboration to access specific resources. Consumer Users\nManaged through Entra ID B2C, primarily for applications requiring customer-facing authentication. Service Principals Application-Based\nCreated through Azure‚Äôs Application Registrations. Managed Identities User Assigned: Created independently and can be assigned to multiple resources. System Assigned: Automatically spun up and managed by Azure for a specific resource; deleted when the resource is removed. Other Identity Types Device Identities: Entra ID registered, joined, or hybrid-joined devices. External Identities: Federated identities from other identity providers. Group Identities: Security groups or Microsoft 365 Groups in Entra ID‚Äîyes, groups can effectively act like identities. Role-Based Identities: Azure RBAC roles that grant specific privileges. Temporary Identities: Temporary Access Pass (TAP), offering time-limited access. Even if a group isn‚Äôt a ‚Äúuser‚Äù in the traditional sense, having the ability to access certain resources means it demands the same level of security and oversight as a standard user account.\nPractical Tips to Fortify Your Azure Identities Securing identities doesn‚Äôt have to be an uphill battle. Small, strategic steps can dramatically improve your security stance. Below are tried-and-tested measures for both users and workload identities.\nTips for User Accounts Enable Multi-Factor Authentication (MFA)\nIf you do just one thing, do this. MFA blocks the lion‚Äôs share of password-based attacks. Adopt Phishing-Resistant Methods\nEspecially for privileged roles‚Äîoptions like FIDO2 security keys or certificate-based authentication can significantly reduce phishing risk. Explore Passwordless Authentication\nServices like Windows Hello or FIDO2 keys offer both greater convenience and stronger security. Use Conditional Access Policies\nDefine when and where users can log in. For instance, block sign-ins from untrusted devices or geographies. Monitor \u0026amp; Review Frequently\nRegularly audit guest accounts and app permissions to maintain the principle of least privilege. Leverage Built-In Azure Identity Tools\nMicrosoft Entra and Azure AD Identity Protection can automatically flag high-risk activities like risky user or risky sign-in events. Tips for Workload Identities (Service Principals / Managed Identities) Adopt Managed Identities\nInstead of hardcoding credentials in applications, let Azure handle identity lifecycle management. This limits the risk of credential leaks. Enforce the Principle of Least Privilege\nDevelopment often requires broad privileges, but production environments demand precision. Narrow permissions before going live. Avoid Assigning Owners to High-Privilege Apps\nIf a low-privilege user is the ‚Äúowner‚Äù of an app that has a powerful scope (e.g., ‚ÄòDirectory.ReadWrite.All‚Äô), you‚Äôre creating an escalated privilege pathway. Continuously Monitor \u0026amp; Review\nReassess user and app permissions to ensure they remain aligned with operational needs. Securing Azure identities is no longer a ‚Äúnice-to-have‚Äù but an absolute must in today‚Äôs threat landscape. By understanding the range of identity types available, choosing them wisely, and implementing robust security measures‚Äîfrom MFA and passwordless methods to managed identities‚Äîyou‚Äôll significantly decrease your organization‚Äôs risk. After all, identities are now your frontline defense. Keeping them secure keeps everything else safe, too.\n","date":"2025-02-20T06:00:00Z","permalink":"/psychic-octo-potato/posts/2025-02-20-identities/","title":"üîí Securing Azure Identities"},{"content":"Keeping your GitHub repositories clean is crucial for maintainability. Over time, branches pile up, making it difficult to track what‚Äôs relevant. If you‚Äôre managing multiple repositories in an organization, manually identifying stale branches can be a hassle.\nLuckily, with the GitHub CLI (gh), you can automate this process and generate a report of all non-main branches along with their last authors.\nThis guide walks you through a Bash script that:\n‚úÖ Retrieves all repositories in an organization\n‚úÖ Lists branches, excluding main, master, and azure-master\n‚úÖ Identifies the last commit author for each branch\n‚úÖ Groups the results by author for better visibility\nüîß Prerequisites Before running the script, make sure:\nYou have GitHub CLI (gh) installed and authenticated (gh auth login). You have appropriate permissions to list repositories and fetch branch details in your organization. You\u0026rsquo;re running a Unix-based system (Linux/macOS or WSL for Windows). üìú The Script Here‚Äôs the complete Bash script to scan all repositories in your GitHub organization and generate a stale branch report:\n# Set Variables org=\u0026#34;\u0026lt;Replace with your GitHub Organization name\u0026gt;\u0026#34; raw_output_file=\u0026#34;branches.txt\u0026#34; report_file=\u0026#34;report.txt\u0026#34; # Clear previous output \u0026gt; \u0026#34;$raw_output_file\u0026#34; # Get the repositories as JSON and extract names repos=$(gh repo list \u0026#34;$org\u0026#34; --json name --jq \u0026#39;.[].name\u0026#39;) # Function to get branch author safely get_author() { local org=$1 local repo=$2 local branch=$3 local author # Try fetching author name author=$(gh api \u0026#34;/repos/$org/$repo/branches/$branch\u0026#34; --jq \u0026#39;.commit.commit.author.name\u0026#39; 2\u0026gt;/dev/null) # If author is empty, return \u0026#34;Unknown\u0026#34; if [[ -z \u0026#34;$author\u0026#34; ]]; then author=\u0026#34;Unknown\u0026#34; fi # Write to output file echo \u0026#34; - Author: $author\u0026#34; \u0026gt;\u0026gt; \u0026#34;$raw_output_file\u0026#34; } # Loop through each repository for repo in $repos; do echo \u0026#34;- repo: $repo\u0026#34; \u0026gt;\u0026gt; \u0026#34;$raw_output_file\u0026#34; # Get all branches in the repository branches=$(gh api \u0026#34;/repos/$org/$repo/branches\u0026#34; --jq \u0026#39;.[].name\u0026#39;) # Loop through each branch for branch in $branches; do # Skip master, azure-master, and main if [[ \u0026#34;$branch\u0026#34; == \u0026#34;master\u0026#34; || \u0026#34;$branch\u0026#34; == \u0026#34;azure-master\u0026#34; || \u0026#34;$branch\u0026#34; == \u0026#34;main\u0026#34; ]]; then continue fi echo \u0026#34; - Branch: $branch\u0026#34; \u0026gt;\u0026gt; \u0026#34;$raw_output_file\u0026#34; # Fetch branch author get_author \u0026#34;$org\u0026#34; \u0026#34;$repo\u0026#34; \u0026#34;$branch\u0026#34; done done declare -A author_repos # Declare an associative array # Ensure the array is cleared before each run unset author_repos declare -A author_repos # Clear previous report \u0026gt; \u0026#34;$report_file\u0026#34; # Read and process output file while IFS= read -r line; do if [[ $line == \u0026#34;- repo: \u0026#34;* ]]; then repo=$(echo \u0026#34;$line\u0026#34; | awk \u0026#39;{print $3}\u0026#39;) elif [[ $line == \u0026#34; - Branch: \u0026#34;* ]]; then branch=$(echo \u0026#34;$line\u0026#34; | awk \u0026#39;{print $3}\u0026#39;) elif [[ $line == \u0026#34; - Author: \u0026#34;* ]]; then author=$(echo \u0026#34;$line\u0026#34; | sed \u0026#39;s/ - Author: //\u0026#39;) # Extract author name # Store branch under author author_repos[\u0026#34;$author\u0026#34;]+=$\u0026#39;\\n\u0026#39;\u0026#34;- $repo -\u0026gt; $branch\u0026#34; fi done \u0026lt; \u0026#34;$raw_output_file\u0026#34; # Print grouped results for author in \u0026#34;${!author_repos[@]}\u0026#34;; do echo \u0026#34;Author: $author\u0026#34; \u0026gt;\u0026gt; \u0026#34;$report_file\u0026#34; echo \u0026#34;${author_repos[$author]}\u0026#34; \u0026gt;\u0026gt; \u0026#34;$report_file\u0026#34; echo \u0026gt;\u0026gt; \u0026#34;$report_file\u0026#34; done cat \u0026#34;$report_file\u0026#34; üìä Example Output Once executed, the script produces a report grouped by author, making it easy to find out who owns stale branches:\nAuthor: Alice - repo1 -\u0026gt; feature/login-page - repo2 -\u0026gt; hotfix/payment-fix Author: Bob - repo3 -\u0026gt; refactor/api-updates - repo1 -\u0026gt; test/legacy-integration Author: Unknown - repo4 -\u0026gt; bugfix/session-timeout üî• Why This Matters Easier Maintenance ‚Äì Identify branches that can be deleted or merged. Better Collaboration ‚Äì Reach out to authors to confirm branch status. Improved Performance ‚Äì Reducing unnecessary branches speeds up repository operations. You can extend this script further to:\n‚úÖ Filter branches by last commit date\n‚úÖ Automatically delete stale branches (with gh api -X DELETE)\n‚úÖ Generate a GitHub issue or PR listing stale branches\nWould love to hear how you customize this for your workflow! üöÄ\n","date":"2025-02-14T01:00:00Z","permalink":"/psychic-octo-potato/posts/2025-02-14-how-to-retrieve-stale-branches-github-organization/","title":"üöÄ How to Retrieve Stale Branches Across All Repositories in a GitHub Organization"},{"content":"Azure Storage automatically stores multiple copies of your data to protect against failures, power outages, and even massive natural disasters. Redundancy ensures that your data remains available and durable even when failures occur.\nThis guide covers all redundancy options available in Azure Storage and how they impact data durability, availability, and failover scenarios.\nüåç Primary Region Redundancy Azure Storage always maintains three copies of your data in the primary region. There are two replication options:\nüîπ LRS (Locally Redundant Storage)\nüîπ ZRS (Zone-Redundant Storage)\nüü¢ Locally Redundant Storage (LRS) LRS synchronously copies your data three times within a single physical location in the primary region.\n‚úÖ Lowest-cost option\n‚ö†Ô∏è Not recommended for applications requiring high availability\nLocally Redundant Storage (LRS) üîµ Zone-Redundant Storage (ZRS) ZRS synchronously replicates data across three availability zones within the primary region.\n‚úÖ Recommended for high-availability applications\n‚úÖ Protects against data center failures\nZone Redundant Storage (ZRS) üåé Secondary Region Redundancy (Geo-Redundancy) For higher durability, Azure allows replicating data to a secondary region, located hundreds of miles away from the primary region.\nWhen creating a storage account, you select the primary region, and Azure assigns a paired secondary region (which cannot be changed).\nAzure Storage provides two geo-redundancy options:\nüîπ GRS (Geo-Redundant Storage)\nüîπ GZRS (Geo-Zone-Redundant Storage)\nKey Difference: In both cases, the secondary region always uses LRS (three copies) for durability. However, the primary region\u0026rsquo;s replication method differs.\nüü° Geo-Redundant Storage (GRS) GRS copies data:\nSynchronously (LRS) within the primary region Asynchronously to a single physical location in the secondary region ‚úÖ Protects against regional outages\n‚ö†Ô∏è Data in the secondary region is not readable unless failover occurs\nGeo-Redundant Storage (GRS) üî¥ Geo-Zone-Redundant Storage (GZRS) GZRS combines the benefits of ZRS + GRS:\nSynchronously (ZRS) replicates across three availability zones in the primary region Asynchronously copies to a single location in the secondary region ‚úÖ Best for mission-critical applications\n‚úÖ Protects against both zonal \u0026amp; regional failures\nGeo-Zone-Redundant Storage (GZRS) üìñ Read Access to Secondary Region By default, GRS and GZRS replicate data to a secondary region but do not allow direct access.\nHowever, if your application requires read access to the secondary region during a primary region outage, you can enable:\nüîπ Read-Access Geo-Redundant Storage (RA-GRS)\nüîπ Read-Access Geo-Zone-Redundant Storage (RA-GZRS)\n‚úÖ Data can be read from the secondary region\n‚ö†Ô∏è Secondary region lags behind the primary (async replication)\nNote: In a disaster scenario, some data might be lost since replication to the secondary region is asynchronous.\nOverview üìä Comparison: Durability \u0026amp; Availability Durability \u0026amp; Availability Parameters Parameter LRS ZRS (RA-)GRS (RA-)GZRS Durability (per year) ‚â• 11 9\u0026rsquo;s ‚â• 12 9\u0026rsquo;s ‚â• 16 9\u0026rsquo;s ‚â• 16 9\u0026rsquo;s Availability (read requests) ‚â• 99.9% (99% for Cool/Archive) ‚â• 99.9% (99% for Cool/Archive) ‚â• 99.9% for GRS / 99.99% for RA-GRS ‚â• 99.9% for GZRS / 99.99% for RA-GZRS Availability (write requests) ‚â• 99.9% (99% for Cool/Archive) ‚â• 99.9% (99% for Cool/Archive) ‚â• 99.9% ‚â• 99.9% Number of copies of data 3 copies (single location) 3 copies (across zones) 6 copies (3 primary + 3 secondary) 6 copies (ZRS primary + LRS secondary) Availability Based on Outage Scenarios Failure Scenario LRS ZRS (RA-)GRS (RA-)GZRS Node failure within a data center ‚úÖ ‚úÖ ‚úÖ ‚úÖ Single data center failure ‚ùå ‚úÖ ‚úÖ ‚úÖ Primary region failure (regional outage) ‚ùå ‚ùå ‚úÖ ‚úÖ Read access to secondary during primary outage ‚ùå ‚ùå ‚úÖ (RA-GRS) ‚úÖ (RA-GZRS) üèÜ Which Azure Storage Redundancy Should You Choose? Use Case Best Option Cost-sensitive workloads, backups, non-critical data LRS High availability within the primary region ZRS Disaster recovery and regional failover protection GRS Mission-critical workloads requiring both zonal \u0026amp; regional protection GZRS Applications requiring immediate read access to secondary RA-GRS / RA-GZRS üõ† Final Thoughts Azure Storage offers multiple redundancy options to ensure data durability and availability. Choosing the right replication strategy depends on:\n‚úîÔ∏è Business requirements ‚Äì Do you need cross-region failover?\n‚úîÔ∏è Cost considerations ‚Äì ZRS and GZRS are costlier but offer better availability.\n‚úîÔ∏è Read requirements ‚Äì Do you need read access to the secondary region?\nIf you‚Äôre running mission-critical applications, GZRS (or RA-GZRS) is your best bet. Otherwise, ZRS or GRS might be sufficient depending on your redundancy needs.\nüöÄ What‚Äôs your go-to storage redundancy option? Drop a comment below! üëá\n","date":"2023-03-20T06:00:00Z","permalink":"/psychic-octo-potato/posts/2023-03-20-azure-storage-redundancy-data-availability-durability/","title":"üîπ Azure Storage Redundancy: Ensuring Data Availability and Durability"},{"content":"Azure Load Balancing Explained: Choosing the Right Option What is Load Balancing? Load balancing is the even distribution of network traffic across a group of backend computing resources or servers. The primary goals of load balancing are:\n‚úÖ Optimizing resource utilization\n‚úÖ Maximizing throughput \u0026amp; performance\n‚úÖ Minimizing response time\n‚úÖ Ensuring high availability\n‚úÖ Preventing overload on a single resource\nIn Azure, there are multiple load-balancing options, each designed for different traffic types and use cases.\nüîç Azure Load Balancing Options Service Scope Recommended for Layer Azure Load Balancer Regional Non-HTTP(S) workloads Layer 4 Traffic Manager Global DNS-based traffic routing Layer 7 (DNS) Azure Application Gateway Regional HTTP(S) web traffic Layer 7 Azure Front Door Global Web applications, API acceleration Layer 7 Load Balancing Decision Tree Now, let‚Äôs explore each of these services in detail.\nüåç Azure Load Balancer (ALB) Azure Load Balancer Azure Load Balancer is a Layer 4 (TCP/UDP) load-balancing service designed for high-performance and ultra-low-latency traffic. It efficiently distributes inbound and outbound traffic while ensuring high availability across Availability Zones.\nTypes of Azure Load Balancers Type Purpose Public Load Balancer Distributes internet-facing traffic across VMs in a VNet. Internal Load Balancer Distributes private network traffic within Azure. ALB Public vs Internal Availability Zone Configurations Mode Behavior Zone Redundant Uses a single IP, surviving zone failures. Zonal Restricts traffic to a specific zone. ALB Zone Redundant Standard vs. Basic Load Balancer Feature Standard Basic Backend pool size 1000 VMs 300 VMs Health probes TCP, HTTP, HTTPS TCP, HTTP Secure by default ‚úÖ Yes ‚ùå No HA Ports ‚úÖ Available ‚ùå Not available SLA ‚úÖ 99.99% ‚ùå Not available üåê Azure Traffic Manager (ATM) Azure Traffic Manager Traffic Manager is a DNS-based global load balancer, designed to distribute traffic across multiple Azure regions. It does not directly route traffic‚Äîinstead, it resolves requests to the nearest healthy backend.\nHow It Works 1Ô∏è‚É£ A client requests a domain (e.g., app.contoso.com).\n2Ô∏è‚É£ The DNS system redirects to contoso.trafficmanager.net.\n3Ô∏è‚É£ Traffic Manager selects a backend using health checks \u0026amp; routing rules.\n4Ô∏è‚É£ The client receives the IP of the closest, available backend and connects directly.\nAzure Traffic Manager Setup Routing Methods Routing Method Use Case Priority Primary backend with failover options. Weighted Distribute traffic based on weights. Performance Route traffic to the closest backend. Geographic Route traffic based on user location. MultiValue Return multiple healthy endpoints. Subnet Route based on user IP ranges. Traffic Manager Routing Traffic Manager is ideal for:\n‚úîÔ∏è Failover between Azure regions\n‚úîÔ∏è Multi-region deployments\n‚úîÔ∏è Hybrid cloud environments\nüîπ Azure Application Gateway (APG) Azure Application Gateway Application Gateway is a Layer 7 load balancer designed specifically for HTTP(S) traffic. It provides advanced web traffic routing, SSL offloading, and Web Application Firewall (WAF) integration.\nKey Features ‚úÖ Path-based routing ‚Üí Direct requests to different backends based on URL paths.\n‚úÖ Session affinity ‚Üí Keep users connected to the same backend server.\n‚úÖ SSL Termination ‚Üí Offload SSL decryption to reduce backend CPU usage.\n‚úÖ Autoscaling ‚Üí Dynamically scale based on traffic load.\nApplication Gateway Flow Best for:\n‚úîÔ∏è Web applications that require advanced traffic routing.\n‚úîÔ∏è Security-conscious deployments using WAF protection.\nüåé Azure Front Door (AFD) Azure Front Door Azure Front Door is a global Layer 7 service that combines load balancing, caching, acceleration, and security into one solution. It ensures high availability and low-latency for web applications.\nKey Capabilities ‚úÖ Global HTTP(S) load balancing ‚Üí Route traffic to the nearest healthy region.\n‚úÖ SSL offloading \u0026amp; URL rewriting ‚Üí Enhance security \u0026amp; performance.\n‚úÖ Caching \u0026amp; acceleration ‚Üí Reduce latency via Edge locations.\n‚úÖ DDoS Protection \u0026amp; WAF ‚Üí Secure web apps from threats.\nüí° Front Door vs. Traffic Manager:\nüîπ Front Door ‚Üí Routes traffic in real-time based on latency.\nüîπ Traffic Manager ‚Üí Routes via DNS resolution, which is slower due to caching.\nBest for:\n‚úîÔ∏è Global applications that need low latency.\n‚úîÔ∏è Web APIs requiring intelligent traffic routing.\nüåç Global vs. Regional Load Balancing Service Scope Use Case Azure Front Door Global HTTP(S) traffic acceleration \u0026amp; load balancing. Traffic Manager Global DNS-based traffic routing. Application Gateway Regional Web application load balancing. Azure Load Balancer Regional Non-HTTP(S) workloads. üí° When to Choose Which? Scenario Recommended Service Distribute global HTTP(S) traffic Azure Front Door Route traffic between regions via DNS Traffic Manager Load balance internal traffic within Azure Azure Load Balancer Optimize web application performance Azure Application Gateway üìå Final Thoughts Azure offers multiple load balancing solutions, each designed for specific traffic types, regions, and use cases. Whether you\u0026rsquo;re building a global web application or optimizing regional traffic, choosing the right service is key to maximizing performance, availability, and security.\nüí° Summary:\n‚úîÔ∏è Use Front Door for global web acceleration.\n‚úîÔ∏è Use Traffic Manager for DNS-based failover.\n‚úîÔ∏è Use Application Gateway for web app security \u0026amp; routing.\n‚úîÔ∏è Use Azure Load Balancer for high-performance, low-latency workloads.\n","date":"2022-06-17T06:00:00Z","permalink":"/psychic-octo-potato/posts/2022-06-17-azure-load-balancing-explained/","title":"üîç Azure Load Balancing Explained: Choosing the Right Option"},{"content":"This blog post captures my notes from the AZ-700 course, which is designed to teach Network Engineers how to design, implement, and maintain Azure networking solutions. The course covers a wide range of networking topics, including:\nDesigning, implementing, and managing core Azure networking infrastructure Hybrid networking connections for on-premises integration Load balancing strategies for optimizing traffic distribution Routing and private access to Azure services Network security and traffic filtering Monitoring and troubleshooting network connectivity 1. Virtual Networks (VNets) Azure Virtual Networks (VNets) are the backbone of networking in Azure, allowing resources to communicate securely.\nVNet Capabilities Azure VNets support:\n‚úÖ Communication with the internet\n‚úÖ Communication between Azure resources\n‚úÖ Secure connectivity to on-premises networks\n‚úÖ Traffic filtering using NSGs (Network Security Groups)\n‚úÖ Routing network traffic efficiently\nVNet Address Space Azure VNets use private IP address ranges as defined in RFC 1918:\nIP Range Prefix 10.0.0.0 - 10.255.255.255 10/8 172.16.0.0 - 172.31.255.255 172.16/12 192.168.0.0 - 192.168.255.255 192.168/16 Subnet Allocation Azure reserves 5 IPs per subnet:\nüîπ x.x.x.0 ‚Üí Network address\nüîπ x.x.x.1 ‚Üí Default gateway\nüîπ x.x.x.2 \u0026amp; x.x.x.3 ‚Üí Azure DNS mapping\nüîπ x.x.x.255 ‚Üí Broadcast address\n2. Scopes in Azure In Azure, every resource must have a unique name within its defined scope. Scopes are hierarchical:\n1Ô∏è‚É£ Global (e.g., Storage Accounts)\n2Ô∏è‚É£ Management Group\n3Ô∏è‚É£ Subscription\n4Ô∏è‚É£ Resource Group (e.g., VNets)\n5Ô∏è‚É£ Resource (individual resource instances)\n3. Regions \u0026amp; Availability Zones Regions \u0026amp; Subscriptions Resources in a VNet must be in the same region, but cross-region connectivity is possible. VNets can be linked across different subscriptions. Availability Zones (AZs) Availability Zones provide high availability by distributing resources across physically separate data centers within a region.\nüîπ Zonal Services ‚Üí Resources pinned to a specific zone\nüîπ Zone-Redundant Services ‚Üí Automatically replicated across zones\nüîπ Non-Regional Services ‚Üí Resilient to zone-wide and region-wide failures\n4. Public IPs in Azure Public IPs enable external communication for Azure resources. They can be static (unchanging) or dynamic (reassigned upon restart).\nPublic IP Type Allocation Security Zone Support Basic SKU Static / Dynamic Open by default ‚ùå No AZ support Standard SKU Static only Secure by default (NSG required) ‚úÖ Zone-redundant 5. DNS Resolution in Azure Azure provides both public and private DNS services to resolve domain names.\nPublic DNS Azure DNS manages internet-facing domain names and supports:\nüîπ A / AAAA records for IPv4/IPv6\nüîπ CNAME records for aliasing domains\nPrivate DNS For internal name resolution within VNets, Azure supports:\n1Ô∏è‚É£ Azure DNS Private Zones\n2Ô∏è‚É£ Azure-provided name resolution\n3Ô∏è‚É£ Custom DNS servers\nüîπ Azure\u0026rsquo;s built-in DNS resolver: 168.63.129.16\nDNS forwarding allows on-premises resources to resolve Azure hostnames, ensuring seamless hybrid connectivity.\nüìå Example: Conditional Forwarding\nTo resolve hostnames across VNets, use custom DNS servers with conditional forwarding rules.\n6. VNet Peering for Cross-Network Connectivity Azure VNet Peering allows seamless communication between VNets without a VPN.\nPeering Type Scope Performance Regional Peering Same Azure region High bandwidth, low latency Global Peering Cross-region Uses Azure backbone VNet Peering Benefits ‚úÖ Secure private communication (no internet exposure)\n‚úÖ No need for VPN gateways\n‚úÖ Supports NSGs for access control\n‚úÖ Works across subscriptions and tenants\nPeering 7. Gateway Transit for Shared VPN Access Gateway Transit allows one VNet to use another VNet‚Äôs VPN gateway for cross-premises connectivity.\nüí° Use case: A hub-and-spoke topology where a single gateway in the hub VNet provides VPN access to multiple spokes.\nGateway Transit 8. Azure Traffic Routing Azure manages traffic routing through:\n1Ô∏è‚É£ System Routes (default routes created by Azure) üîπ Internet traffic ‚Üí Sent via the default Internet Gateway\nüîπ Private traffic ‚Üí Stays within the VNet\n2Ô∏è‚É£ Custom Routes (UDRs - User Defined Routes) Use route tables to override system routes.\nüí° Example: Direct traffic to a firewall appliance instead of the default gateway.\nDefault Route Table Source Destination Next Hop Default 0.0.0.0/0 Internet Default 10.0.0.0/8 None Default 192.168.0.0/16 None Final Thoughts This post provides a comprehensive summary of key Azure networking concepts from AZ-700. Understanding VNets, peering, DNS, and routing is essential for designing scalable, secure, and high-performing cloud networks.\nüìå Key Takeaways:\n‚úÖ Master VNet and subnet design to optimize address space\n‚úÖ Use peering and gateway transit for hybrid connectivity\n‚úÖ Leverage DNS solutions to simplify name resolution\n‚úÖ Control traffic with NSGs \u0026amp; UDRs for security and compliance\nüî• If you\u0026rsquo;re studying for AZ-700, focus on hands-on labs to reinforce concepts! üöÄ\n","date":"2022-06-03T06:00:00Z","permalink":"/psychic-octo-potato/posts/2022-06-03-az-700-prep-highlights/","title":"üìò AZ-700 Prep Highlights"}]